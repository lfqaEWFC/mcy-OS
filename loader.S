%include "boot.inc"

section loader vstart=LOADER_BASE_ADDR

; ================================================================
;                       loader 启动段
; ================================================================
LOADER_STACK_TOP    equ LOADER_BASE_ADDR
jmp loader_start                                  ; 跳过 GDT 段定义区，直接跳转到 loader 入口执行


; ================================================================
;                       GDT 表定义区
; ================================================================
GDT_BASE:
    dd 0x00000000                                 ; 第一个描述符必须全 0（空描述符）
    dd 0x00000000

; ---------------------- 代码段描述符 ----------------------------
CODE_DESC:
    dd 0x0000FFFF                                 ; 段界限低 16 位 + 段基址低 16 位
    dd DESC_CODE_HIGH4                            ; 段基址高字节 + 段属性

; ---------------------- 数据段/栈段描述符 ----------------------
DATA_STACK_DESC:
    dd 0x0000FFFF
    dd DESC_DATA_HIGH4

; ---------------------- 显存段描述符 ---------------------------
VIDEO_DESC:
    dd 0x80000007                                 ; 段基址 = 0xB8000, 段界限 = 0x7 ，即(0xBFFFF-0xB8000)/4KB
    dd DESC_VIDEO_HIGH4                           ; DPL = 0, 数据段，可写，用于 gs 操作显存

; ---------------------- GDT 长度与选择子 ------------------------
GDT_SIZE        equ $ - GDT_BASE
GDT_LIMIT       equ GDT_SIZE - 1

times 60 dq 0                                     ; 预留 60 个描述符空间（后续可添加系统段、TSS 等）

SELECTOR_CODE   equ (0x0001 << 3) + TI_GDT + RPL0 ; = (CODE_DESC - GDT_BASE) / 8 + TI_GDT + RPL0
SELECTOR_DATA   equ (0x0002 << 3) + TI_GDT + RPL0
SELECTOR_VIDEO  equ (0x0003 << 3) + TI_GDT + RPL0

; ---------------------- GDTR 指针结构 ---------------------------
gdt_ptr:
    dw GDT_LIMIT                                  ; 前 2 字节为 GDT 界限
    dd GDT_BASE                                   ; 后 4 字节为 GDT 起始线性地址

; ================================================================
;                       启动提示信息
; ================================================================
loadermsg db '2 loader in real.'


; ================================================================
;                       loader 主体
; ================================================================
loader_start:

; ------------------------------------------------
; BIOS 中断 0x10 - 功能号 0x13：打印字符串
; ------------------------------------------------
; 输入参数：
;   AH = 13h          （显示字符串）
;   AL = 01h          （显示后光标移动）
;   BH = 页号（0）
;   BL = 字符属性（1Fh = 蓝底粉红字）
;   CX = 字符串长度
;   (DH, DL) = 起始位置（行, 列）
;   ES:BP = 字符串地址
; ------------------------------------------------
    mov sp, LOADER_BASE_ADDR
    mov bp, loadermsg
    mov cx, 17
    mov ax, 0x1301
    mov bx, 0x001f
    mov dx, 0x1800
    int 0x10                                      ; BIOS 显示字符串 "2 loader in real."


; ================================================================
;                   进入保护模式前的准备工作
; ================================================================
; 三步走：
;   1. 开启 A20 地址线（允许访问 1MB 以上内存）
;   2. 加载 GDT（全局描述符表）
;   3. 置 CR0 的 PE 位（进入保护模式）
; ================================================================

; ------------------ Step 1: 开启 A20 地址线 ----------------------
; A20 控制：端口 0x92 的第 1 位控制 A20。
; 打开后 CPU 可以访问线性地址超过 0xFFFFF 的内存。
    in al, 0x92
    or al, 0000_0010B
    out 0x92, al

; ------------------ Step 2: 加载 GDT -----------------------------
; 将 gdt_ptr 中定义的地址与界限加载到 GDTR 寄存器。
    lgdt [gdt_ptr]

; ------------------ Step 3: 设置 CR0.PE = 1 ----------------------
; 打开保护模式标志位（第0位）。
    mov eax, cr0
    or eax, 0x00000001
    mov cr0, eax

; ------------------ 跳转至保护模式代码段 ------------------------
; 注意：必须使用 “远跳转（jmp dword sel:offset）”
;       刷新 CPU 预取队列，使指令执行进入保护模式。
    jmp SELECTOR_CODE:p_mode_start


; ================================================================
;                     保护模式正式开始
; ================================================================
[bits 32]
p_mode_start:

; ------------------ 加载段寄存器 -------------------------------
    mov ax, SELECTOR_DATA
    mov ds, ax
    mov es, ax
    mov ss, ax

; ------------------ 设置 GS 指向显存段 --------------------------
    mov ax, SELECTOR_VIDEO
    mov gs, ax

; ------------------ 测试输出：在屏幕第二行第一个位置打印 'P' --
; 文本模式下：每个字符占用两个字节（字符 + 属性）
; 0xB8000 + 160 = 第二行第一个字符处
    mov byte [gs:160], 'P'

; ------------------ 无限循环，保持当前状态 ----------------------
    jmp $

