; ============================================
; 主引导程序 (MBR)
; ============================================

%include "boot.inc"

SECTION MBR vstart=0x7c00

; -----------------------------------------------------------
; 初始化段寄存器
; -----------------------------------------------------------
    mov ax, cs
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov fs, ax
    mov sp, 0x7c00
    mov ax, 0xb800
    mov gs, ax

; -----------------------------------------------------------
; 清屏
; 利用 BIOS 中断 0x10 的 0x06 号功能（上卷窗口）
; -----------------------------------------------------------
; INT 0x10 - 功能号 0x06 ：上卷窗口
; 输入参数：
;   AH = 0x06
;   AL = 上卷的行数 (为 0 表示全部)
;   BH = 上卷行属性
;   (CL,CH) = 窗口左上角坐标 (X,Y)
;   (DL,DH) = 窗口右下角坐标 (X,Y)
; -----------------------------------------------------------
    mov ax, 0600h
    mov bx, 0700h
    mov cx, 0                       ; 左上角: (0,0)
    mov dx, 184Fh                   ; 右下角: (79,24)
    int 10h                         ; 调用 BIOS 清屏

; -----------------------------------------------------------
; 在屏幕上输出字符串 “MBR”
; -----------------------------------------------------------
    mov byte [gs:0x00], '1'
    mov byte [gs:0x01], 0xA4

    mov byte [gs:0x02], ' '
    mov byte [gs:0x03], 0xA4

    mov byte [gs:0x04], 'M'
    mov byte [gs:0x05], 0xA4

    mov byte [gs:0x06], 'B'
    mov byte [gs:0x07], 0xA4

    mov byte [gs:0x08], 'R'
    mov byte [gs:0x09], 0xA4

; -----------------------------------------------------------
; 读取 Loader 程序（从硬盘加载至内存）
; -----------------------------------------------------------
    mov eax, LOADER_START_SECTOR    ; 起始扇区 LBA 地址
    mov bx,  LOADER_BASE_ADDR       ; 写入的内存地址
    mov cx,  4                      ; 待读入的扇区数
    call rd_disk_m_16               ; 调用读盘函数

; -----------------------------------------------------------
; 跳转到 Loader 起始地址执行
; -----------------------------------------------------------
    jmp LOADER_BASE_ADDR

; -----------------------------------------------------------
; 主程序结束
; -----------------------------------------------------------


; ===========================================================
; 子程序：rd_disk_m_16 —— 从磁盘读取 n 个扇区
; ===========================================================
; 参数：
;   eax = LBA 扇区号
;   bx = 将数据写入的内存地址
;   cx = 待读取的扇区数
; ===========================================================

rd_disk_m_16:
    mov esi, eax                    ; 备份 LBA
    mov di,  cx                     ; 备份扇区数

; -----------------------------------------------------------
; 第 1 步：设置要读取的扇区数（端口 0x1F2）
; -----------------------------------------------------------
    mov dx, 0x1F2
    mov al, cl
    out dx, al                      ; 写入待读扇区数

; -----------------------------------------------------------
; 第 2 步：设置要读取的 LBA 地址（端口 0x1F3~0x1F6）
; -----------------------------------------------------------
    mov eax, esi                    ; 恢复 LBA

    mov dx, 0x1F3                   ; LBA 地址 7~0 位
    out dx, al

    mov cl, 8
    shr eax, cl
    mov dx, 0x1F4                   ; LBA 地址 15~8 位
    out dx, al

    shr eax, cl
    mov dx, 0x1F5                   ; LBA 地址 23~16 位
    out dx, al

    shr eax, cl
    and al, 0x0F                    ; 仅取 LBA 24~27 位
    or  al, 0xE0                    ; 设置 7~4 位为 1110 (LBA 模式)
    mov dx, 0x1F6
    out dx, al

; -----------------------------------------------------------
; 第 3 步：向 0x1F7 端口写入读命令 0x20
; -----------------------------------------------------------
    mov dx, 0x1F7
    mov al, 0x20
    out dx, al

; -----------------------------------------------------------
; 第 4 步：检测硬盘状态是否准备好
; -----------------------------------------------------------
.not_ready:
    nop
    in al, dx
    and al, 0x88                    ; 第7位=忙, 第3位=准备好
;   and 命令在运算结束之后cpu的运算单元会根据运算结果是否为0改变标志寄存器中的ZF位，
;       而运算结果会被存储回到al寄存器中
    cmp al, 0x08
;   cmp 命令会比较数字是否相等，而结果会通过改变ZF位进行存储
    jnz .not_ready                  ; 若未准备好，继续等待
;   jnz 命令会看ZF是否为1,如果为1就会退出循环

; -----------------------------------------------------------
; 第 5 步：从 0x1F0 端口读取数据
; -----------------------------------------------------------
    mov ax, di                      ; di = 扇区数
    mov dx, 256                     ; 每扇区 512 字节 / 每次读取 2 字节 = 256 次
    mul dx                          ; 得到总的读取次数
;   mul 指令永远使用 AX 作为一个隐含操作数，并把运算结果放回到 AX 中
    mov cx, ax                      ; cx = 循环次数
    mov dx, 0x1F0

;   注意：
;      这里只是设置了下面循环的参数（即要读取几个扇区）
;      而具体的对磁盘io端口读取起点和状态的设置在第二步和第三步就完成了

.go_on_read:
    in ax, dx
    mov [bx], ax
    add bx, 2
    loop .go_on_read
;   loop 命令与前面的jnz相似，
;        只不过loop检查是cx寄存器中的数字并递减它，
;        如果递减为0就会退出循环
    ret

; -----------------------------------------------------------
; 主引导扇区结束标志
; -----------------------------------------------------------
    times 510 - ($ - $$) db 0
    db 0x55, 0xAA

; 总结:
; 1. 初始化段寄存器并设置栈与显存段 (GS -> 0xB800)。
; 2. 使用 BIOS int 10h 清屏并直接写显存显示 "MBR"。
; 3. 通过对 ATA/IDE I/O 端口 (0x1F2..0x1F7) 写入扇区数、LBA 和命令，
;    发起读扇区操作（Read Sectors）。
; 4. 轮询状态端口 (0x1F7) 直到设备准备好 (DRQ=1, BSY=0)。
; 5. 通过数据端口 (0x1F0) 读取 512*count 字节到内存缓冲区 (DS:BX)。
; 6. 完成后跳转到 loader 的起始地址执行。
